// Generated by CoffeeScript 1.8.0
(function() {
  var CHR, DOMParser, SvgPath, T, TRM, alert, badge, debug, echo, em_size, help, info, log, math, module, options, rpr, source, urge, warn, whisper, xpath,
    __slice = [].slice;

  DOMParser = (require('xmldom')).DOMParser;

  math = require('./math');

  xpath = require('xpath');

  CHR = require('coffeenode-chr');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'svg2ttf/svg-to-svg-font';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  urge = TRM.get_logger('urge', badge);

  whisper = TRM.get_logger('whisper', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  SvgPath = require('svgpath');


  /* https://github.com/loveencounterflow/coffeenode-teacup */

  T = require('coffeenode-teacup');

  module = 36;

  em_size = 4096;

  options = {

    /* Coordinates of first glyph outline: */
    'offset': [module * 5, module * 5],

    /* Size of grid and font design size: */
    'module': module,
    'em-size': em_size,

    /* Number of glyph rows between two rulers plus one: */
    'block-height': 9,

    /* CID of first glyph outline: */
    'cid0': 0xe000,
    'row-length': 16,
    'ascent': +0.8 * em_size,
    'descent': -0.2 * em_size
  };

  options['scale'] = em_size / module;

  this.load = function(source) {
    var actual_row, block_count, center, cid, col, d, doc, dx, dy, entry, fallback, glyphs, max_cid, parser, path, path_count, paths, row, rows, select, selector, x, y, _, _i, _j, _len, _ref;
    glyphs = {};
    fallback = null;
    max_cid = -Infinity;
    parser = new DOMParser();
    doc = parser.parseFromString(source, 'application/xml');
    select = xpath.useNamespaces({
      'SVG': 'http://www.w3.org/2000/svg'
    });
    selector = '//*[local-name()="path"]';
    selector = '/*[local-name()="svg"]/*[local-name()="path"]';
    selector = '//*[local-name()="path"]';
    paths = select(selector, doc);
    path_count = paths.length;
    paths = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = paths.length; _i < _len; _i++) {
        path = paths[_i];
        if (!/^x-/.test(path.getAttribute('id'))) {
          _results.push(path);
        }
      }
      return _results;
    })();
    debug("found " + paths.length + " outlines");
    debug("skipped " + (path_count - paths.length) + " non-outline elements");
    process.exit();
    rows = {};
    for (_i = 0, _len = paths.length; _i < _len; _i++) {
      path = paths[_i];
      d = path.getAttribute('d');
      path = (new SvgPath(d)).abs();
      center = this.center_from_absolute_path(path);
      x = center[0], y = center[1];
      x -= options['offset'][0];
      y -= options['offset'][1];
      col = Math.floor(x / options['module']);
      row = Math.floor(y / options['module']);
      block_count = Math.floor(row / options['block-height']);
      actual_row = row - block_count;
      cid = options['cid0'] + actual_row * options['row-length'] + col;
      max_cid = Math.max(max_cid, cid);
      dx = -(col * options['module']) - options['offset'][0];
      dy = -(row * options['module']) - options['offset'][1];
      path = path.translate(dx, dy).scale(1, -1).translate(0, options['module']).scale(options['scale']).round(0);

      /* !!! */
      if (cid < options['cid0']) {
        fallback = path;
      } else {
        if (glyphs[cid] != null) {
          warn("duplicate CID: 0x" + (cid.toString(16)));
        }
        glyphs[cid] = [cid, path];
      }

      /* !!! */
    }
    for (cid = _j = _ref = options['cid0']; _ref <= max_cid ? _j <= max_cid : _j >= max_cid; cid = _ref <= max_cid ? ++_j : --_j) {
      if (glyphs[cid] == null) {
        glyphs[cid] = [cid, fallback];
      }
    }
    glyphs = (function() {
      var _results;
      _results = [];
      for (_ in glyphs) {
        entry = glyphs[_];
        _results.push(entry);
      }
      return _results;
    })();
    glyphs.sort(function(a, b) {
      if (a[0] > b[0]) {
        return +1;
      }
      if (a[0] < b[0]) {
        return -1;
      }
      return 0;
    });
    return echo(this.f(glyphs));
  };

  this.center_from_absolute_path = function(path) {
    return this.center_from_absolute_points(this.points_from_absolute_path(path));
  };

  this.center_from_absolute_points = function(path) {
    var node_count, sum_x, sum_y, x, y, _i, _len, _ref;
    node_count = path.length;
    sum_x = 0;
    sum_y = 0;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      _ref = path[_i], x = _ref[0], y = _ref[1];
      if (!((x != null) && (y != null))) {
        throw new Error("found undefined points in path");
      }
      sum_x += x;
      sum_y += y;
    }
    return [sum_x / node_count, sum_y / node_count];
  };

  this.points_from_absolute_path = function(path) {
    var R, command, idx, last_x, last_y, node, x, xy, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    R = [];
    _ref = path['segments'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      command = node[0], xy = 2 <= node.length ? __slice.call(node, 1) : [];

      /* Ignore closepath command: */
      if (/^[zZ]$/.test(command)) {
        continue;
      }
      if (!/^[MLHVCSQTA]$/.test(command)) {
        throw new Error("unknown command " + (rpr(command)) + " in path " + (rpr(path)));
      }
      switch (command) {
        case 'H':
          _ref1 = [xy[0], last_y], x = _ref1[0], y = _ref1[1];
          R.push([x, y]);
          break;
        case 'V':
          _ref2 = [last_x, xy[0]], x = _ref2[0], y = _ref2[1];
          R.push([x, y]);
          break;
        case 'M':
        case 'L':
          for (idx = _j = 0, _ref3 = xy.length; _j < _ref3; idx = _j += +2) {
            _ref4 = [xy[idx], xy[idx + 1]], x = _ref4[0], y = _ref4[1];
            R.push([x, y]);
          }
          break;
        case 'C':
          for (idx = _k = 0, _ref5 = xy.length; _k < _ref5; idx = _k += +6) {
            _ref6 = [xy[idx + 4], xy[idx + 5]], x = _ref6[0], y = _ref6[1];
            R.push([x, y]);
          }
          break;
        case 'S':
          for (idx = _l = 0, _ref7 = xy.length; _l < _ref7; idx = _l += +4) {
            _ref8 = [xy[idx + 2], xy[idx + 3]], x = _ref8[0], y = _ref8[1];
            R.push([x, y]);
          }
          break;
        default:
          _ref9 = [null, null], x = _ref9[0], y = _ref9[1];
          R.push([x, y]);
      }
      last_x = x;
      last_y = y;
    }
    return R;
  };

  T.SVG = function() {
    var P, Q;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    Q = {
      'xmlns': 'http://www.w3.org/2000/svg'
    };
    return T.TAG.apply(T, ['svg', Q].concat(__slice.call(P)));
  };

  T.DEFS = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return T.TAG.apply(T, ['defs'].concat(__slice.call(P)));
  };

  T.FONT = function() {
    var P, Q;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    Q = {
      'id': 'jizura2svg',
      'horiz-adv-x': options['module'] * options['scale']
    };
    return T.TAG.apply(T, ['font', Q].concat(__slice.call(P)));
  };

  T.FONT_FACE = function() {
    var Q;
    Q = {
      'id': 'jizura2svg',
      'units-per-em': options['module'] * options['scale'],

      /* TAINT probably wrong values */
      'ascent': options['ascent'],
      'descent': options['descent']
    };

    /* TAINT kludge */
    return T.RAW((T.render((function(_this) {
      return function() {
        return T.TAG('font-face', Q);
      };
    })(this))).replace(/><\/font-face>$/, ' />'));
  };

  T.GLYPH = function(cid, path) {
    var Q;
    Q = {
      unicode: CHR.as_chr(cid),
      d: T._rpr_path(path)
    };
    return T.TAG('glyph', Q);
  };

  T.MARKER = function(xy, r) {
    if (r == null) {
      r = 10;
    }
    return T.TAG('circle', {
      cx: xy[0],
      cy: xy[1],
      r: r,
      fill: '#f00'
    });
  };

  T._rpr_path = function(path) {
    var s;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = path['segments'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _results.push(s[0] + s.slice(1).join(','));
      }
      return _results;
    })()).join(' ');
  };

  T.path = function(path) {
    var path_txt;
    path_txt = T._rpr_path(path);
    return T.TAG('path', {
      d: path_txt,
      fill: '#000'
    });
  };

  this.f = function(glyphs) {
    return T.render((function(_this) {
      return function() {
        T.RAW("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");

        /* must preserve space at end of DOCTYPE declaration */
        T.RAW("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" >\n");
        return T.SVG(function() {
          T.TEXT('\n');
          T.DEFS(function() {
            T.TEXT('\n');
            T.FONT(function() {
              var cid, path, _i, _len, _ref, _results;
              T.TEXT('\n');
              T.FONT_FACE();
              T.TEXT('\n');
              _results = [];
              for (_i = 0, _len = glyphs.length; _i < _len; _i++) {
                _ref = glyphs[_i], cid = _ref[0], path = _ref[1];
                T.RAW("<!-- " + (cid.toString(16)) + " -->");
                T.GLYPH(cid, path);
                _results.push(T.TEXT('\n'));
              }
              return _results;
            });
            return T.TEXT('\n');
          });
          return T.TEXT('\n');
        });
      };
    })(this));
    return null;
  };

  this.demo = function() {
    var d, path;
    d = "M168,525.89c38,36,48,48,46,81s5,47-46,52 s-88,35-91-27s-21-73,11-92S168,525.89,168,525.89z";
    path = new SvgPath(d).scale(0.5).translate(100, 200).abs().round(0);
    debug(JSON.stringify(path));
    help(this.points_from_absolute_path(path));
    help(this.center_from_absolute_path(path));
    return debug(this.f(path));
  };

  if (module.parent == null) {
    source = (require('fs')).readFileSync('/Volumes/Storage/jizura-materials-2/jizura-font-v3/jizura3-0000.svg', {
      encoding: 'utf-8'
    });
    this.load(source);
  }

}).call(this);
