// Generated by CoffeeScript 1.8.0
(function() {
  var CHR, DOMParser, SvgPath, T, TRM, alert, badge, debug, echo, em_size, glob, help, info, log, math, module, njs_fs, njs_path, options, route_glob, routes, rpr, urge, warn, whisper, xpath,
    __slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path');

  DOMParser = (require('xmldom-silent')).DOMParser;

  math = require('./math');

  xpath = require('xpath');

  CHR = require('coffeenode-chr');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'svg2ttf/svg-to-svg-font';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  urge = TRM.get_logger('urge', badge);

  whisper = TRM.get_logger('whisper', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  SvgPath = require('svgpath');


  /* https://github.com/loveencounterflow/coffeenode-teacup */

  T = require('coffeenode-teacup');


  /* https://github.com/isaacs/node-glob */

  glob = require('glob');

  module = 36;

  em_size = 4096;

  options = {

    /* Coordinates of first glyph outline: */
    'offset': [module * 4, module * 4],

    /* Size of grid and font design size: */
    'module': module,

    /* Number of glyph rows between two rulers plus one: */
    'block-height': 9,

    /* CID of first glyph outline: */
    'row-length': 16,
    'em-size': em_size,
    'ascent': +0.8 * em_size,
    'descent': -0.2 * em_size
  };

  options['scale'] = em_size / module;

  this.load = function() {
    var actual_row, block_count, center, cid, cid0, col, d, doc, dx, dy, entry, fallback, fallback_count, fallback_source, filename, glyph_count, glyphs, input_routes, local_glyph_count, local_max_cid, local_min_cid, max_cid, max_cid_hex, min_cid, min_cid_hex, parser, path, path_count, paths, prefix, route, row, select, selector, source, x, y, _, _i, _j, _k, _len, _len1;
    input_routes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    glyphs = {};
    glyph_count = 0;
    parser = new DOMParser();
    select = xpath.useNamespaces({
      'SVG': 'http://www.w3.org/2000/svg'
    });
    selector = '//SVG:svg/SVG:path';
    fallback = null;
    fallback_count = 0;
    fallback_source = null;
    min_cid = +Infinity;
    max_cid = -Infinity;
    for (_i = 0, _len = input_routes.length; _i < _len; _i++) {
      route = input_routes[_i];
      local_min_cid = +Infinity;
      local_max_cid = -Infinity;
      local_glyph_count = 0;
      filename = njs_path.basename(route);
      if (filename !== 'jizura3-e200.svg') {
        continue;
      }
      cid0 = this._cid0_from_route(route);
      source = njs_fs.readFileSync(route, {
        encoding: 'utf-8'
      });
      doc = parser.parseFromString(source, 'application/xml');
      paths = select(selector, doc);
      path_count = paths.length;
      info("" + filename + ": found " + paths.length + " outlines");
      for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
        path = paths[_j];
        d = path.getAttribute('d');
        path = (new SvgPath(d)).abs();
        center = this.center_from_absolute_path(path);
        x = center[0], y = center[1];
        x -= options['offset'][0];
        y -= options['offset'][1];
        col = Math.floor(x / options['module']);
        row = Math.floor(y / options['module']);
        block_count = Math.floor(row / options['block-height']);
        actual_row = row - block_count;
        cid = cid0 + actual_row * options['row-length'] + col;
        dx = -(col * options['module']) - options['offset'][0];
        dy = -(row * options['module']) - options['offset'][1];
        path = path.translate(dx, dy).scale(1, -1).translate(0, options['module']).scale(options['scale']).round(0);
        if (cid < cid0) {
          prefix = fallback != null ? 're-' : '';
          fallback = path;
          fallback_source = filename;
          help("" + filename + ": " + prefix + "assigned fallback");
        } else {
          min_cid = Math.min(min_cid, cid);
          max_cid = Math.max(max_cid, cid);
          local_min_cid = Math.min(local_min_cid, cid);
          local_max_cid = Math.max(local_max_cid, cid);
          if (glyphs[cid] != null) {
            warn("" + filename + ": duplicate CID: 0x" + (cid.toString(16)));
          } else {
            glyphs[cid] = [cid, path];
            glyph_count += 1;
            local_glyph_count += 1;
          }
        }
      }
      if (local_glyph_count > 0) {
        min_cid_hex = '0x' + local_min_cid.toString(16);
        max_cid_hex = '0x' + local_max_cid.toString(16);
        help("" + filename + ": added " + glyph_count + " glyph outlines in [ " + min_cid_hex + " .. " + max_cid_hex + " ]");
      } else {
        warn("" + filename + ": no glyphs found");
      }
    }
    if (glyph_count === 0) {
      warn("no glyphs found; terminating");
      return null;
    }
    for (cid = _k = min_cid; min_cid <= max_cid ? _k <= max_cid : _k >= max_cid; cid = min_cid <= max_cid ? ++_k : --_k) {
      if (glyphs[cid] == null) {
        glyphs[cid] = [cid, fallback];
        fallback_count += 1;
      }
    }
    if (fallback_count > 0) {
      help("filled " + fallback_count + " positions with fallback outline from " + fallback_source);
    }
    glyphs = (function() {
      var _results;
      _results = [];
      for (_ in glyphs) {
        entry = glyphs[_];
        _results.push(entry);
      }
      return _results;
    })();
    glyphs.sort(function(a, b) {
      if (a[0] > b[0]) {
        return +1;
      }
      if (a[0] < b[0]) {
        return -1;
      }
      return 0;
    });
    return echo(this.f(glyphs));
  };

  this._cid0_from_route = function(route) {
    var R, match;
    match = route.match(/-([0-9a-f]+)\.svg$/);
    if (match == null) {
      throw new Error("unable to parse route " + (rpr(route)));
    }
    R = parseInt(match[1], 16);
    if (!((0x0000 <= R && R <= 0x10ffff))) {
      throw new Error("illegal CID in route " + (rpr(route)));
    }
    return R;
  };

  this.center_from_absolute_path = function(path) {
    return this.center_from_absolute_points(this.points_from_absolute_path(path));
  };

  this.center_from_absolute_points = function(path) {
    var node_count, sum_x, sum_y, x, y, _i, _len, _ref;
    node_count = path.length;
    sum_x = 0;
    sum_y = 0;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      _ref = path[_i], x = _ref[0], y = _ref[1];
      if (!((x != null) && (y != null))) {
        throw new Error("found undefined points in path");
      }
      sum_x += x;
      sum_y += y;
    }
    return [sum_x / node_count, sum_y / node_count];
  };

  this.points_from_absolute_path = function(path) {
    var R, command, idx, last_x, last_y, node, x, xy, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    R = [];
    _ref = path['segments'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      command = node[0], xy = 2 <= node.length ? __slice.call(node, 1) : [];

      /* Ignore closepath command: */
      if (/^[zZ]$/.test(command)) {
        continue;
      }
      if (!/^[MLHVCSQTA]$/.test(command)) {
        throw new Error("unknown command " + (rpr(command)) + " in path " + (rpr(path)));
      }
      switch (command) {
        case 'H':
          _ref1 = [xy[0], last_y], x = _ref1[0], y = _ref1[1];
          R.push([x, y]);
          break;
        case 'V':
          _ref2 = [last_x, xy[0]], x = _ref2[0], y = _ref2[1];
          R.push([x, y]);
          break;
        case 'M':
        case 'L':
          for (idx = _j = 0, _ref3 = xy.length; _j < _ref3; idx = _j += +2) {
            _ref4 = [xy[idx], xy[idx + 1]], x = _ref4[0], y = _ref4[1];
            R.push([x, y]);
          }
          break;
        case 'C':
          for (idx = _k = 0, _ref5 = xy.length; _k < _ref5; idx = _k += +6) {
            _ref6 = [xy[idx + 4], xy[idx + 5]], x = _ref6[0], y = _ref6[1];
            R.push([x, y]);
          }
          break;
        case 'S':
          for (idx = _l = 0, _ref7 = xy.length; _l < _ref7; idx = _l += +4) {
            _ref8 = [xy[idx + 2], xy[idx + 3]], x = _ref8[0], y = _ref8[1];
            R.push([x, y]);
          }
          break;
        default:
          _ref9 = [null, null], x = _ref9[0], y = _ref9[1];
          R.push([x, y]);
      }
      last_x = x;
      last_y = y;
    }
    return R;
  };

  T.SVG = function() {
    var P, Q;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    Q = {
      'xmlns': 'http://www.w3.org/2000/svg'
    };
    return T.TAG.apply(T, ['svg', Q].concat(__slice.call(P)));
  };

  T.DEFS = function() {
    var P;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return T.TAG.apply(T, ['defs'].concat(__slice.call(P)));
  };

  T.FONT = function() {
    var P, Q;
    P = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    Q = {
      'id': 'jizura2svg',
      'horiz-adv-x': options['module'] * options['scale']
    };
    return T.TAG.apply(T, ['font', Q].concat(__slice.call(P)));
  };

  T.FONT_FACE = function() {
    var Q;
    Q = {
      'id': 'jizura2svg',
      'units-per-em': options['module'] * options['scale'],

      /* TAINT probably wrong values */
      'ascent': options['ascent'],
      'descent': options['descent']
    };

    /* TAINT kludge */
    return T.RAW((T.render((function(_this) {
      return function() {
        return T.TAG('font-face', Q);
      };
    })(this))).replace(/><\/font-face>$/, ' />'));
  };

  T.GLYPH = function(cid, path) {
    var Q;
    Q = {
      unicode: CHR.as_chr(cid),
      d: T._rpr_path(path)
    };
    return T.TAG('glyph', Q);
  };

  T.MARKER = function(xy, r) {
    if (r == null) {
      r = 10;
    }
    return T.TAG('circle', {
      cx: xy[0],
      cy: xy[1],
      r: r,
      fill: '#f00'
    });
  };

  T._rpr_path = function(path) {
    var s;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = path['segments'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        _results.push(s[0] + s.slice(1).join(','));
      }
      return _results;
    })()).join(' ');
  };

  T.path = function(path) {
    var path_txt;
    path_txt = T._rpr_path(path);
    return T.TAG('path', {
      d: path_txt,
      fill: '#000'
    });
  };

  this.f = function(glyphs) {
    return T.render((function(_this) {
      return function() {
        T.RAW("<?xml version=\"1.0\" encoding=\"utf-8\"?>\n");

        /* must preserve space at end of DOCTYPE declaration */
        T.RAW("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\" >\n");
        return T.SVG(function() {
          T.TEXT('\n');
          T.DEFS(function() {
            T.TEXT('\n');
            T.FONT(function() {
              var cid, path, _i, _len, _ref, _results;
              T.TEXT('\n');
              T.FONT_FACE();
              T.TEXT('\n');
              _results = [];
              for (_i = 0, _len = glyphs.length; _i < _len; _i++) {
                _ref = glyphs[_i], cid = _ref[0], path = _ref[1];
                T.RAW("<!-- " + (cid.toString(16)) + " -->");
                T.GLYPH(cid, path);
                _results.push(T.TEXT('\n'));
              }
              return _results;
            });
            return T.TEXT('\n');
          });
          return T.TEXT('\n');
        });
      };
    })(this));
    return null;
  };

  this.demo = function() {
    var d, path;
    d = "M168,525.89c38,36,48,48,46,81s5,47-46,52 s-88,35-91-27s-21-73,11-92S168,525.89,168,525.89z";
    path = new SvgPath(d).scale(0.5).translate(100, 200).abs().round(0);
    debug(JSON.stringify(path));
    help(this.points_from_absolute_path(path));
    help(this.center_from_absolute_path(path));
    return debug(this.f(path));
  };

  if (module.parent == null) {
    route_glob = '/Volumes/Storage/jizura-materials-2/jizura-font-v3/jizura3-*([0-9a-f]).svg';
    routes = glob.sync(route_glob);
    this.load.apply(this, routes);
  }

}).call(this);
